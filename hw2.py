# -*- coding: utf-8 -*-
"""hw2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GrZ7zX1Z9ePR22OuSAokcL-aSS6-IH1o
"""

from google.colab import drive
from google.colab import files

drive.mount('/content/drive')
base_path = '/content/drive/My Drive/CSE 272/Homework2'



import gzip
import pandas as pd
import json

def parse(path):
  data = gzip.open(path, 'rb')
  for line in data:
    yield json.loads(line)

def getDF(path):
  i = 0
  df = {}
  for d in parse(path):
    df[i] = d
    i += 1
  return pd.DataFrame.from_dict(df, orient='index')


file_path = base_path + '/Video_Games_5.json.json.gz'
df = getDF(file_path)

df

import datetime
def make_date(string_date):
  temp = string_date.replace(',', '')
  temp = temp.split(' ')
  return datetime.datetime(month=int(temp[0]), day=int(temp[1]), year=int(temp[2]))

# convert to datetime
df['reviewTime'] = df['reviewTime'].astype(str)
df['reviewTime'] = df['reviewTime'].apply(make_date)

# use the latest review for each user as the test set, and the earlier reviews as the the training set
test_set = df.loc[df.groupby('reviewerID')['reviewTime'].idxmax()]
train_set = df.drop(test_set.index)
display(train_set)

# build requisite structures
# dictionary with items as keys and list of users that reviewed that item
items = {}
# dictionary with users as keys and list of items that they have reviewed
users = {}
# dictionary with (user,item) tuples as keys and the rating given

ratings = {}

for index, row in train_set.iterrows():
  item_name = row['asin']
  user_name = row['reviewerID']
  rating = row['overall']

  # store the fact that this item was rated by the given user
  if not item_name in items.keys():
    items[item_name] = []
  items[item_name].append(user_name)

  # store the fact that this user rated the given item
  if not user_name in users.keys():
    users[user_name] = []
  users[user_name].append(item_name)

  # store the rating for the user_name item_name pair
  ratings[(user_name, item_name)] = rating

# do we still have memory?

user_averages = {}
# calculate the average ratings for each user
for user_name in users.keys():
  # get the list of items they rated
  rated_items = users[user_name]
  total_ratings = 0.0
  for item in rated_items:
    total_ratings += ratings[(user_name, item)]
  user_averages[user_name] = total_ratings / len(rated_items)

item_averages = {}
# calculate the average rating for each item
for item in items.keys():
  rated_by = items[item]
  total_ratings = 0.0
  for user_name in rated_by:
    total_ratings += ratings[(user_name, item)]
  item_averages[item] = total_ratings / len(rated_by)

import math

user_similarities = {}

for user in users.keys():
  # get the list of items rated by this user
  rated_items = users[user]
  # get list of users who also rated one of these items
  similar_users = []
  user_similarities[user] = {}

  for item in rated_items:
    for similar_user in items[item]:
      if similar_user != user and similar_user not in similar_users:
        similar_users.append(similar_user)

  for similar_user in similar_users:
    # let's calculate how similar they are to us
    # get list of items that both users have rated
    shared_items = []
    for item in rated_items:
      if item in users[similar_user]:
        shared_items.append(item)
    if len(shared_items) == 1:
      # the two users only have 1 item in common, so it is impossible to see the correlation between ratings
      # instead let's use the # of items in common / total items rated by both parties
      weight = (2 * len(shared_items)) / (len(users[similar_user]) + len(users[user]))
      user_similarities[user][similar_user] = weight
      continue

    # time to calculate our similarities
    top_sum = 0
    user_square = 0
    similar_square = 0
    for item in shared_items:
      user_val = ratings[(user, item)] - user_averages[user]
      similar_user_val = ratings[(similar_user, item)] - user_averages[similar_user]
      if user_val == 0 or similar_user_val == 0:
        continue

      top_sum += (user_val * similar_user_val)
      user_square += (user_val * user_val)
      similar_square += (similar_square * similar_square)
    
    user_square = math.sqrt(user_square)
    similar_square = math.sqrt(similar_square)
    if user_square == 0 or similar_square == 0:
      # one of the ratings has no deviation, let's just use the number of similar items rated over total rated between each party
      weight = (2 * len(shared_items)) / (len(users[similar_user]) + len(users[user]))
      user_similarities[user][similar_user] = weight
      continue

    weight = top_sum / (user_square * similar_square)
    user_similarities[user][similar_user] = weight

"""https://github.com/Microsoft/Recommenders

https://github.com/microsoft/recommenders/tree/main/examples/00_quick_start

https://github.com/microsoft/recommenders/blob/main/examples/00_quick_start/ncf_movielens.ipynb
"""

# use what we have built to predict the rating of the game given by this user
def predict(input_x):
  # get the list of other users who have rated this item
  predictions = []
  for index, row in input_x.iterrows():
    item_name = row['asin']
    user_name = row['reviewerID']
    prediction = user_averages[user_name]

    top_sum = 0
    bottom_sum = 0

    # get list of other users that have rated this item
    if not item_name in items.keys():
      # we have no ratings for this item, simply return user average
      predictions.append(prediction)
      continue
    other_users = items[item_name]
    our_similarities = user_similarities[user]

    for similar_user in other_users:
      #do we have a similarity score for this user?
      if similar_user in our_similarities.keys():
        top_sum += our_similarities[similar_user] * (ratings[(similar_user, item_name)] - user_averages[similar_user]) 
        bottom_sum += our_similarities[similar_user]

    if top_sum == 0 or bottom_sum == 0:
      # let's just weight our average with the item's average
      combined_ratings = len(items[item_name]) + len(users[user_name])
      rating = ((user_averages[user] * len(users[user_name])) / combined_ratings)
      rating += ((item_averages[item_name] * len(items[item_name])) /combined_ratings)
      predictions.append(rating)
    else:
      prediction += (top_sum / bottom_sum)
      predictions.append(prediction)
  return predictions

def user_average_predict(input_x):
  predictions = []
  for index, row in input_x.iterrows():
    user_name = row['reviewerID']
    prediction = 2.5
    if user_name in user_averages.keys():
      prediction = user_averages[user_name]
    predictions.append(prediction)
  return predictions

def item_average_predict(input_x):
  predictions = []
  for index, row in input_x.iterrows():
    item_name = row['asin']
    prediction = 2.5
    if item_name in item_averages.keys():
      prediction = item_averages[item]
    predictions.append(prediction)
  
  return predictions

def weighted_average_predict(input_x):
  predictions = []
  for inex, row in input_x.iterrows():
    item_name = row['asin']
    user_name = row['reviewerID']
    prediction = 2.5
    item_avg = 0
    user_avg = 0
    if item_name in item_averages.keys():
      item_avg = item_averages[item_name]
    if user_name in user_averages.keys():
      user_avg = user_averages[user_name]
    
    if item_avg == 0 or user_avg == 0:
      predictions.append(prediction)
    else:
      user_ratings = len(users[user_name])
      item_ratings = len(items[item_name])
      total_ratings = item_ratings + user_ratings
      item_avg = item_avg * item_ratings
      user_avg = user_avg * user_ratings
      prediction = ((item_avg + user_avg) / total_ratings)
      predictions.append(prediction)

  return predictions

from sklearn.metrics import mean_squared_error
from sklearn.metrics import mean_absolute_error

columns = ['reviewerID', 'asin']

X_test = test_set[columns]
y_test = test_set['overall']

y_pred = predict(X_test)
user_pred = user_average_predict(X_test)
item_pred = item_average_predict(X_test)
weighted_pred = weighted_average_predict(X_test)


mse = mean_squared_error(y_test, y_pred)
rmse = math.sqrt(mse)
mae = mean_absolute_error(y_test, y_pred)

user_mse = mean_squared_error(y_test, user_pred)
item_mse = mean_squared_error(y_test, item_pred)
weighted_mse = mean_squared_error(y_test, weighted_pred)

user_rmse = math.sqrt(user_mse)
item_rmse = math.sqrt(item_mse)
weighted_rmse = math.sqrt(weighted_mse)

user_mae = mean_absolute_error(y_test, user_pred)
item_mae = mean_absolute_error(y_test, item_pred)
weighted_mae = mean_absolute_error(y_test, weighted_pred)

print('collaborative rmse: ', rmse)
print('collaborative mae: ', mae)

print('----------------------------------------------------------------------')

print('user average rmse: ', user_rmse)
print('user average mae: ', user_mae)

print('----------------------------------------------------------------------')

print('item average rmse: ', item_rmse)
print('item average mae: ', item_mae)

print('----------------------------------------------------------------------')


print('weighted average rmse: ', weighted_rmse)
print('weighted average mae: ', weighted_mae)